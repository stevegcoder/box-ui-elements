/**
 * @was-flow
 * @file Skills sidebar component
 * @author Box
 */
import * as React from 'react';
import { FormattedMessage } from 'react-intl';
import noop from 'lodash/noop';
import { SKILLS_TRANSCRIPT, ORIGIN_SKILLS_SIDEBAR } from '../../constants';
import messages from '../messages';
import { withAPIContext } from '../APIContext';
import { withErrorBoundary } from '../ErrorBoundary';
class SkillsSidebar extends React.PureComponent {
    constructor() {
        super(...arguments);
        this.state = {
            errors: {},
        };
        /**
         * Updates Preview with transcript data
         *
         * @private
         * @param {Array<SkillCard>} cards - Skills cards
         * @return {void}
         */
        this.updatePreviewTranscript = (cards) => {
            const { getPreview, getViewer } = this.props;
            const preview = getPreview ? getPreview() : null;
            const viewer = getViewer ? getViewer() : null;
            const transcriptCard = cards.find(card => card.skill_card_type === SKILLS_TRANSCRIPT);
            if (!transcriptCard || !preview) {
                return;
            }
            if (!viewer) {
                preview.addListener('load', ({ viewer: loadedViewer }) => {
                    if (typeof loadedViewer.loadAutoGeneratedCaptions === 'function') {
                        loadedViewer.loadAutoGeneratedCaptions(transcriptCard);
                    }
                });
            }
            else if (typeof viewer.loadAutoGeneratedCaptions === 'function') {
                viewer.loadAutoGeneratedCaptions(transcriptCard);
            }
        };
        /**
         * Updates skill metadata
         *
         * @private
         * @param {string} id - File id
         * @return {void}
         */
        this.onSave = (index, removes = [], adds = [], replaces = []) => {
            const { api, file } = this.props;
            const { cards = [], errors } = this.state;
            const { permissions = {} } = file;
            const card = cards[index];
            const path = `/cards/${index}`;
            const ops = [];
            if (!permissions.can_upload || !card) {
                return;
            }
            if (Array.isArray(replaces)) {
                replaces.forEach(({ replaced, replacement }) => {
                    const idx = card.entries.findIndex(entry => entry === replaced);
                    if (idx > -1) {
                        ops.push({
                            op: 'replace',
                            path: `${path}/entries/${idx}`,
                            value: replacement,
                        });
                    }
                });
            }
            if (Array.isArray(removes)) {
                const deletes = [];
                removes.forEach(removed => {
                    const idx = card.entries.findIndex(entry => entry === removed);
                    if (idx > -1) {
                        deletes.push(idx);
                    }
                });
                deletes
                    .sort()
                    .reverse()
                    .forEach(idx => {
                    ops.push({
                        op: 'remove',
                        path: `${path}/entries/${idx}`,
                    });
                });
            }
            if (Array.isArray(adds)) {
                adds.forEach(added => {
                    ops.push({
                        op: 'add',
                        path: `${path}/entries/-`,
                        value: added,
                    });
                });
            }
            // If no ops, don't proceed
            if (ops.length === 0) {
                return;
            }
            // Add test ops before any other ops
            ops.splice(0, 0, {
                op: 'test',
                path,
                value: card,
            });
            api.getMetadataAPI(false).updateSkills(file, ops, (updatedCards) => {
                const clone = Object.assign({}, errors);
                delete clone[index];
                this.updatePreviewTranscript(updatedCards);
                this.setState({ cards: updatedCards, errors: clone });
            }, () => {
                const clone = Object.assign({}, errors);
                clone[index] = true;
                this.setState({ errors: clone });
            });
        };
    }
    componentDidMount() {
        const { api, file } = this.props;
        api.getMetadataAPI(false).getSkills(file, (cards) => {
            this.updatePreviewTranscript(cards);
            this.setState({ cards });
        }, noop);
    }
    render() {
        const { file, getViewer } = this.props;
        const { cards, errors } = this.state;
        return title = {} < FormattedMessage;
        {
            messages.sidebarSkillsTitle;
        }
        />}>;
        {
            cards ? file = { file }
                :
            ;
            cards = { cards };
            errors = { errors };
            getViewer = { getViewer };
            onSkillChange = { this: .onSave }
                /  >
            ;
            />;
        }
        /SidebarContent>;
        ;
    }
}
export { SkillsSidebar as SkillsSidebarComponent };
export default withErrorBoundary(ORIGIN_SKILLS_SIDEBAR)(withAPIContext(SkillsSidebar));
//# sourceMappingURL=SkillsSidebar.js.map